// Package parsebenchy provides functionality to parse benchy output.
//
// It would be better to get JSON output from benchy, but it does not appear to support that.
package parsebenchy

import (
	"bufio"
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// Result stores the parsed data for a single benchmark run within a metric.
type measures struct {
	Old   string
	New   string
	Delta string
}

// Maps benchmark name (eg. BM_Parse_Upb_FileDesc<UseArena, Copy>) to a set of measures.
type Result map[string]measures

// Maps metric name (eg. "cpu", "time") to a set of results.
type Metrics map[string]Result

func ParseBenchyValue(data string) (float64, error) {
	// 65.5k Â± 1%
	parts := strings.Split(data, " ")
	val := parts[0]
	multiplier := 1.0

	if val[len(val)-1] == 'k' {
		multiplier = 1000.0
		val = val[:len(val)-1]
	}
	// TODO: handle other units

	asFloat, err := strconv.ParseFloat(val, 64)
	if err != nil {
		return 0, fmt.Errorf("could not parse value as float: %s", val)
	}

	return asFloat * multiplier, nil
}

// Parses benchy output into a data structure.
func ParseBenchyOutput(data string) (*Metrics, error) {
	allMetrics := Metrics{}
	var currentResult *Result

	// Regex to identify the initial "(Generated by...)" line.
	generatedByRegex := regexp.MustCompile(`^\(Generated by`)
	perflabCaseRegex := regexp.MustCompile(`^case_\d:`)
	resultsUploadedRegex := regexp.MustCompile(`^Results uploaded to`)
	// Regex to identify metric header lines (e.g., "name old cpu/op new cpu/op delta")
	// and capture the metric name (e.g., "cpu", "time", "CPU-CYCLES", "speed").
	metricHeaderRegex := regexp.MustCompile(`^name\s+old\s+([A-Za-z0-9-()]+)(?:/op)?\s+new\s+`)
	// Regex to split data lines by two or more whitespace characters.
	// This acts as the column separator.
	dataLineSplitter := regexp.MustCompile(`\s{2,}`)

	scanner := bufio.NewScanner(strings.NewReader(data))

	for scanner.Scan() {
		line := scanner.Text()

		// 1. Skip the "Generated by" line and "case_N:" perflab lines.
		if generatedByRegex.MatchString(line) || resultsUploadedRegex.MatchString(line) || perflabCaseRegex.MatchString(line) {
			continue
		}

		trimmedLine := strings.TrimSpace(line)

		// 2. Handle blank lines: they typically signify the end of a metric block.
		if trimmedLine == "" {
			currentResult = nil // Reset for the next block
			continue
		}

		// 3. Check for metric header lines (e.g., "name old cpu/op ...")
		metricHeaderMatches := metricHeaderRegex.FindStringSubmatch(line)
		if metricHeaderMatches != nil {
			// Start a new metric block.
			metricName := metricHeaderMatches[1] // Captured group (cpu, time, etc.)
			currentResult = &Result{}
			allMetrics[metricName] = *currentResult
			continue // This line was the header, move to the next line.
		}

		// 4. If it's not any of the above, it should be a data line for the current metric.
		if currentResult != nil {
			parts := dataLineSplitter.Split(trimmedLine, 5)

			if len(parts) != 5 {
				return nil, fmt.Errorf("unparseable data line: '%s' (split into %d parts)", trimmedLine, len(parts))
			}

			name := strings.TrimSpace(parts[0])
			res := measures{
				Old:   strings.TrimSpace(parts[1]),
				New:   strings.TrimSpace(parts[2]),
				Delta: strings.TrimSpace(parts[3]),
			}
			(*currentResult)[name] = res
		} else {
			// This case implies a data line appeared without a preceding metric header.
			return nil, fmt.Errorf("data line with no current metric context: '%s'", line)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error scanning input: %w", err)
	}

	return &allMetrics, nil
}
